// Staking Demo
// Author: Steve Ferrigno (@nullun)
//
// Global States:
//	+ A  - Admin
//	+ P  - Paused
//	+ SA - Staking Asset
//	+ RA - Reward Asset
//	+ BT - Begin Timestamp
//	+ ET - End Timestamp
//	+ TS - Total Staked
//	+ TR - Total Rewards (remaining)
//	+ LU - Last Updated
//
// Local States:
//	+ AS - Amount Staked
//	+ AR - Amount Rewarded
//	+ LU - Last Updated
//
#pragma version 6

// Deposit
// Who: Users
// Why: Add an amount of staked assets to the pool, increasing their share of
//      the rewards.
// Group:
//	[ * | axfer | appl | * ]
//	+ Asset Transfer sending staking asset into pool
txna ApplicationArgs 0
method "deposit(axfer)void"
==
bnz method_deposit

// Withdraw
// Who: Users
// Why: Remove an amount of staked assets from the pool, decreasing their share
//      of the rewards.
// Group:
//	[ * | appl | * ]
// Args:
//	+ Staking/Reward Asset
//	+ Amount to withdraw
//	+ Account to withdraw asset to
txna ApplicationArgs 0
method "withdraw(asset,uint64,account)void"
==
bnz method_withdraw

// Config
// Who: Admin
// Why: Pause/unpause the contract, or change admin.
// Group:
//	[ * | appl | * ]
// Args:
//	+ Paused
//	+ Admin
txna ApplicationArgs 0
method "config(bool,account)void"
==
bnz method_config

// Deploy
// Who: Admin
// Why: Used to deploy the contract, defining assets and times.
// Group:
//	[ * | appl | * ]
// Args:
//	+ Staking Asset
//	+ Reward Asset
//	+ Begin Timestamp
//	+ End Timestamp
txna ApplicationArgs 0
method "deploy(asset,asset,uint64,uint64)void"
==
bnz method_deploy

// Init
// Who: Admin
// Why: Initialise the newly deployed contract, funding it with a minimum
//      balance and allowing it to opt in to the required assets.
// Group:
//	[ * | pay | appl | * ]
// Args:
//	+ Staking Asset
//	+ Reward Asset
txna ApplicationArgs 0
method "init(pay,asset,asset)void"
==
bnz method_init

// Update Rewards
// Who: Admin
// Why: Primarily used to supply the initial rewards for the staking contract,
//      but can also be used to add additional rewards before the contract ends.
// Group:
//	[ * | axfer | appl | * ]
// Args:
//	+ Reward Asset
txna ApplicationArgs 0
method "reward(axfer,asset)void"
==
bnz method_reward

err

// Deposit
// Scratch Spaces:
//	0: appl group position
//	1: axfer group position
method_deposit:
	callsub sub_is_not_paused

	// Can only deposit during an OptIn or NoOp
	txn OnCompletion
	int NoOp
	==
	txn OnCompletion
	int OptIn
	==
	||
	assert

	// Store this appl position
	txn GroupIndex
	store 0

	// Store the axfer position relative to the appl position
	load 0
	int 1
	-
	store 1

	// Confirm sender for this appl and the axfer are the same
	// Note: Do we need to care if it came from the same address?
	txn Sender
	load 1
	gtxns Sender
	==
	assert

	// Check the staking asset is being received by the smart contract
	load 1
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==
	assert

	// Add deposit to users local state
	int 0
	byte "AS"
	dup2
	app_local_get
	load 1
	gtxns AssetAmount
	+
	app_local_put

	int 1
	return

// Withdraw
method_withdraw:
	callsub sub_is_not_paused

	txn OnCompletion
	int NoOp
	==
	txn OnCompletion
	int CloseOut
	==
	||
	assert

	txna ApplicationArgs 1
	btoi
	txnas Assets

	txna ApplicationArgs 2
	btoi

	txna ApplicationArgs 3
	btoi
	txnas Accounts

	callsub sub_send_asset

	// If it's a NoOp (0) we can skip the closeout check
	txn OnCompletion
	bz skip_closeout_check

	// Make sure there's no outstanding staked
	txna ApplicationArgs 3
	btoi
	txnas Accounts
	byte "SA"
	app_local_get
	!
	assert

	// Make sure there's no outstanding rewards
	txna ApplicationArgs 3
	btoi
	txnas Accounts
	byte "RA"
	app_local_get
	!
	assert

skip_closeout_check:
	int 1
	return

// Deploy
method_deploy:
	// Can only deploy as a new smart contracts
	txn ApplicationID
	!
	assert

	// Use sender as admin
	int 0
	txnas Accounts
	callsub sub_set_admin

	// Set staking asset
	byte "SA"
	txn ApplicationArgs 1
	btoi
	txnas Assets
	app_global_put

	// Set reward asset
	byte "RA"
	txn ApplicationArgs 2
	btoi
	txnas Assets
	app_global_put

	// Set begin timestamp
	// Must be after LatestTimestamp
	byte "BT"
	txn ApplicationArgs 3
	btoi
	dup
	global LatestTimestamp
	>
	assert
	app_global_put

	// Set end timestamp
	// Must be after begin timestamp
	byte "ET"
	txn ApplicationArgs 4
	btoi
	dup
	txn ApplicationArgs 3
	btoi
	>
	assert
	app_global_put

	int 1
	return

// Init
// Scratch Spaces:
//	0: appl group position
//	1: pay group position
method_init:
	callsub sub_is_admin

	// Store this appl position
	txn GroupIndex
	store 0

	// Store the pay position relative to the appl position
	load 0
	int 1
	-
	store 1

	// Check receiver of payment is this smart contract
	load 1
	gtxns Receiver
	global CurrentApplicationAddress
	==
	assert

	// Check amount is greater than minimum balance requirement
	global CurrentApplicationAddress
	balance
	load 1
	gtxns Amount
	+
	global MinBalance
	txn NumAssets
	int 1
	+
	*
	global MinTxnFee
	txn NumAssets
	*
	+
	>=
	assert

	// OptIn to all assets
	int 1
	store 2
	optin_loop:
	load 2
	txn NumAssets
	<=
	bz optin_complete
	load 2
	txnas ApplicationArgs
	btoi
	txnas Assets
	callsub sub_optin_asset
	load 2
	int 1
	+
	store 2
	b optin_loop

	optin_complete:
	int 1
	return

// Reward
// Scratch Spaces:
//	0: appl group position
//	1: axfer group position
//	2: Reward Balance
method_reward:
	callsub sub_is_admin

	// Store this appl position
	txn GroupIndex
	store 0

	// Store the axfer position relative to the appl position
	load 0
	int 1
	-
	store 1

	// Check previous transaction is of type axfer
	load 1
	gtxns TypeEnum
	int axfer
	==
	assert

	// Check receiver of payment is this smart contract
	load 1
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==
	assert

	// Check received asset is reward
	load 1
	gtxns XferAsset
	byte "RA"
	app_global_get
	==
	assert

	global CurrentApplicationAddress
	byte "RA"
	app_global_get
	txnas Assets
	asset_holding_get AssetBalance
	assert
	store 2

	load 2
	byte "TR"
	app_global_get
	-
	load 1
	gtxns AssetAmount
	>=
	assert


	int 1
	return

// Config
method_config:
	callsub sub_is_admin

	byte "P"
	txna ApplicationArgs 1
	btoi
	!
	!
	app_global_put

	txna ApplicationArgs 2
	btoi
	txnas Accounts
	callsub sub_set_admin

	int 1
	return

/////////////////
// Subroutines //
/////////////////

sub_set_admin:
	byte "A"
	swap
	app_global_put
	retsub

sub_is_not_paused:
	byte "P"
	app_global_get
	!
	assert
	retsub

sub_is_admin:
	txn Sender
	byte "A"
	app_global_get
	==
	assert
	retsub

// sub_optin_asset(asset)
// Arguments:
//	+ Asset
sub_optin_asset:
	itxn_begin

	itxn_field XferAsset

	int axfer
	itxn_field TypeEnum

	global CurrentApplicationAddress
	itxn_field AssetReceiver

	itxn_submit
	retsub

// sub_send_asset(asset,uint64,account)
// Arguments:
//	+ Asset
//	+ Amount
//	+ Account
// Scratch Space:
//	10: asset
//	11: asset amount
//	12: account
sub_send_asset:
	store 12
	store 11
	store 10

	// Check amount is less than or equal to the amount in users local state
	load 11
	load 12
	byte "SA"
	app_local_get
	<=
	assert

	// Remove amount from users local state
	// Note: This could be done without the above check due to underflow errors
	load 12
	byte "SA"
	dup2
	app_local_get
	load 11
	-
	app_local_put

	// Send asset
	itxn_begin

	int axfer
	itxn_field TypeEnum

	load 10
	itxn_field XferAsset

	load 11
	itxn_field AssetAmount

	load 12
	itxn_field AssetReceiver

	int 0
	itxn_field Fee

	itxn_submit
	retsub

